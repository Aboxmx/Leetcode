## 二叉树的最大深度

### 解法一：迭代者，空间小，速度慢

1. 特判  if (root == null) return 0;

2. 根节点先入队

3. 当队列不空时，循环

4. 记录当前队列中的元素，每一轮循环需将当前队列（不计后来加入的）中所有元素出队，并且按层序遍历的方法，入队，每完成一次循环，更新一次深度

5. ~~~java
   
   class Solution {
       public int maxDepth(TreeNode root) {
           if (root == null) return 0;
           LinkedList<TreeNode> queue = new LinkedList<>();
           int deepth = 0;
           queue.offer(root);
   
           while (!queue.isEmpty()) {
               int sz = queue.size();
               while (sz > 0) {
                   TreeNode tmp = queue.poll();
                   if (tmp.left != null) queue.offer(tmp.left);
                   if (tmp.right != null) queue.offer(tmp.right);
                   sz--;
               }
               deepth++;           
           }
           return deepth;
       }
   }
   ~~~

### 解法二：递归者，速度快，空间大

1. 该方法的功能是：求得以root为根的树的最大深度

2. 子方法的功能是：求得maxDepth(root.left),  maxDepth(root.right)

3. 该方法与子方法的关系是：1 + Math.max(maxDepth(root.left), maxDepth(root.right))

4. 递归基：if (root == null) return 0;

5. ~~~java
   class Solution {
       public int maxDepth(TreeNode root) {
           if (root == null) return 0;
           return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));   
       }
   }
   ~~~

